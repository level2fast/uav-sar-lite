function [resampled_sig] = sinc_interp_8_pt_kernel(input_signal, sample_shift, range_bin_spacing)
%SINC_INTERP16 Summary of this function goes here
%   Detailed explanation goes here
           
H =      [-0.003, 0.010, -0.024, 0.062, 0.993, -0.054, 0.021, -0.009; ...
          -0.007, 0.021, -0.049, 0.131, 0.973, -0.098, 0.040, -0.017; ...
          -0.012, 0.032, -0.075, 0.207, 0.941, -0.134, 0.055, -0.023; ...
          -0.016, 0.043, -0.101, 0.287, 0.896, -0.160, 0.066, -0.027; ...
          -0.020, 0.054, -0.125, 0.371, 0.841, -0.176, 0.074, -0.030; ...
          -0.024, 0.063, -0.147, 0.457, 0.776, -0.185, 0.078, -0.031; ...
          -0.027, 0.071, -0.165, 0.542, 0.703, -0.185, 0.079, -0.031; ...
          -0.030, 0.076, -0.178, 0.625, 0.625, -0.178, 0.076, -0.030; ...
          -0.031, 0.079, -0.185, 0.703, 0.542, -0.165, 0.071, -0.027; ...
          -0.031, 0.078, -0.185, 0.776, 0.457, -0.147, 0.063, -0.024; ...
          -0.030, 0.074, -0.176, 0.841, 0.371, -0.125, 0.054, -0.020; ...
          -0.027, 0.066, -0.160, 0.896, 0.287, -0.101, 0.043, -0.016; ...
          -0.023, 0.055, -0.134, 0.941, 0.207, -0.075, 0.032, -0.012; ...
          -0.017, 0.040, -0.098, 0.973, 0.131, -0.049, 0.021, -0.007; ...
          -0.009, 0.021, -0.054, 0.993, 0.062, -0.024, 0.010, -0.003; ...
          -0.000, 0.000, -0.000, 1.000, 0.000, -0.000, 0.000, -0.000; ...
          ];
range_bin_delta = range_bin_spacing;
H_IDX = round(sample_shift/range_bin_delta); % determine fraction of range bin
H = H(H_IDX,:);
H_LEN = length(H);
X = input_signal; 
X_LEN = length(X);
Y = zeros(1, (length(X) + H_LEN) - 1).'; % Define output signal Y (initialized to zero)
Y_LEN = length(Y);
window = kaiser(length(H_LEN),2.5);

% Perform convolution using nested loops
for IDX = 1:Y_LEN % Loop over each point in Y
    for J = 1:H_LEN % Loop over each point in H
        if (IDX - J >= 1) && (IDX - J <= X_LEN)
            Y(IDX) = Y(IDX) + (X(IDX - J) * H(J) * window); % perform convolution and window result
        end
    end
end

% could loop over each pulse and perform convolution using the
% sinc interp kernel weights that correspond to the appropriate
% sample shift
% temp = conv(X,H);

resampled_sig = Y;
end

